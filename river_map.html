<html>
<head>	
	<title>River Basin</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
        -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
	
    <script
    src="https://code.jquery.com/jquery-3.5.1.min.js"
    integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
    crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.6.2/d3.min.js" integrity="sha512-L2eTGYYQqzK5YozYyUVrJKj2ZRnHE3QzV1+1yY6VXHExStF3potRZyEcD/B6sTOe04xYxB21QNLmVTQFcgwovg==" crossorigin="anonymous"></script>

    <style>
        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        .info h4 {
            margin: 0 0 5px;
            color: #777;
        }
        .legend {
            line-height: 18px;
            color: #555;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            margin-bottom: 2px;
            opacity: 0.7;
        }
    </style>
   
</head>
<body>

<div id="mapid">
</div>
<script>
    var getParams = function (url) {
        var params = {};
        var parser = document.createElement('a');
        parser.href = url;
        var query = parser.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            params[pair[0]] = decodeURIComponent(pair[1]);
        }
        return params;
    };
    color_list = [];    
    var default_color_list = [ "#b2df8a", "#a6cee3", "#cab2d6", "#fdbf6f", "#fb9a99", "#33a02c", "#1f78b4", "#6a3d9a", "#ff7f00", "#e31a1c"];
    var geojsons = "";
    
    var minVal = 0;
    var maxVal = 0;
    var custom_grades = [];
    var quantizeScale = d3.scaleQuantize();

    var params = getParams(window.location.href);
    if(params.name)
        sessionStorage.setItem("chart_name", params.name);
    
        if(params.colorlist == undefined){
        color_list = default_color_list;
    }
    else{
        colors = params.colorlist.split(',');
        for(var i=0; i< colors.length; i++)
        {
            color_list.push(colors[i]);
        }
    }
    sessionStorage.setItem("colorlist", color_list);

    if(params.geojson != undefined){
        jsons = params.geojson.split(',');
        for(var i=0; i< jsons.length; i++)
        {
            if(i != 0)
                geojsons += ",";

            geojsons += jsons[i];
            //drawMap(geojsons[i], color_list);
        }
    }
    sessionStorage.setItem("geojson", geojsons);

	//var mymap = L.map('mapid').setView([52.123582, -106.66214], 9);

    

    var map_div = document.querySelector('#mapid');
    width_height_str = 'width: ' + (this.innerWidth-20) + "; height: " + (this.innerHeight-20);
    map_div.setAttribute('style', width_height_str);

    var saskatoon = L.marker([52.133909518197136, -106.66351318359375]).bindPopup('Saskatoon');
    var regina = L.marker([	50.4527, -104.6194]).bindPopup('Regina');
    var prince_albert = L.marker([53.20459312100394, -105.74821472167969]).bindPopup('Prince Albert');
    var north_battleford = L.marker([52.780339216, -108.30047607421875]).bindPopup('North Battleford');

    var cities = L.layerGroup([saskatoon, regina, prince_albert]);
    cities.addLayer(north_battleford);

    var overlayMaps = {
        "Cities": cities
    };

    //var legend_text = [">= 100,000", "10,000-100,000", "1,000-10,000", "100-1,000", "10-100", "1-10", "0.1-1", "0.01-0.1", "0.001-0.01", "< 0.001"];
    var legend_text = [];
    var layers = [];
    


    var mbAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
			'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
    mbUrl = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';

    var grayscale   = L.tileLayer(mbUrl, {id: 'mapbox/light-v9', tileSize: 512, zoomOffset: -1, attribution: mbAttr}),
        streets  = L.tileLayer(mbUrl, {id: 'mapbox/streets-v11', tileSize: 512, zoomOffset: -1, attribution: mbAttr});
    
    var map = L.map('mapid', {
        center: [52.123582, -106.66214],
        zoom: 9,
        layers: [grayscale, cities]
    });

    var baseLayers = {
        "Grayscale": grayscale,
        "Streets": streets
    };

    
    //var demo_color_list_seq = ["#ffffff", "#08306b", "#08519c", "#2171b5", "#4292c6", "#6baed6", "#9ecae1", "#c6dbef", "#deebf7", "#f7fbff" ];

    L.control.layers(baseLayers, overlayMaps).addTo(map);

    var legend = L.control({position: 'bottomleft'});


    drawMap();
    
    var websocket = new WebSocket("ws://127.0.0.1:6789/");
    websocket.onmessage = function (event) {
        d = JSON.parse(event.data);
        console.log(d);
        if(d.chart){
            d.chart = JSON.parse(d.chart.replaceAll("\'", "\""));
            for(var index=0; index<d.chart.length; index++)
            {
                chart_name = sessionStorage.getItem("chart_name");
                if(d.chart[index].to.includes(chart_name)){

                    if(d.chart[index].hasOwnProperty('colorlist')){
                        sessionStorage.removeItem("colorlist");
                        color_list = [];
                        colors = d.chart[index].colorlist.split(',');
                        for(var i=0; i< colors.length; i++)
                        {
                            color_list.push(colors[i]);
                        }

                        sessionStorage.setItem("colorlist", color_list);
                    }
                    if(d.chart[index].hasOwnProperty('geojson')){
                        geojsons = sessionStorage.getItem("geojson").split(',');
                        jsons = d.chart[index].geojson.split(',');
                        for(var i=0; i< jsons.length; i++)
                        {
                            if(!geojsons.includes(jsons[i]))
                                geojsons.push(jsons[i]);
                        }
                        var geojson_str = "";
                        for(var j=0; j< geojsons.length; j++)
                        {
                            if(j != 0)
                                geojson_str += ",";
                            geojson_str += geojsons[j];
                        }
                        
                        sessionStorage.removeItem("geojson");
                        sessionStorage.setItem("geojson", geojson_str);
                    }
                    if(d.chart[index].hasOwnProperty('draw') && d.chart[index].draw == 1){
                        drawMap();
                    }

                }
            }
        }
        
        //drawMap(data.json_file, data.color_list);
    };    

    function drawMap(){
        color_list = sessionStorage.getItem("colorlist").split(',');
        //json_list_str = sessionStorage.getItem("geojson");
        json_list_str = "jeoJSON_al_sk.json";
        minVal = 1000000;
        maxVal = -1000000;
        
        if(json_list_str != "")
        {

            json_list_temp = json_list_str.split(',');
            json_list = [];
            
            for (var k=0; k<json_list_temp.length; k++){
                if(json_list_temp[k] == "" || json_list_temp[k] == undefined)
                    continue;
                else
                    json_list.push(json_list_temp[k]);
            }


            if(json_list.length > 0){

                var counter = 1;
                for (var i=0; i<json_list.length; i++)
                {
                    json_path = json_list[i];
                    fetch(json_path)
                    .then(function(response){
                        return response.json();
                    })
                    .then(function(data){
                        minVal_t = d3.min(data.features, d=> d.properties.flow_acc);
                        maxVal_t = d3.max(data.features, d=> d.properties.flow_acc);

                        if(minVal_t < minVal)
                            minVal = minVal_t;
                        
                        if(maxVal_t > maxVal)
                            maxVal = maxVal_t;
                        
                        if(counter == json_list.length){
                            layers = [];
                            //console.log("Min : " + minVal);
                            //console.log("Max : " + maxVal);
                            temp_array = [];
                            for(it=0; it<color_list.length; it++)
                                temp_array.push(it);
                            
                                //quantizeScale.domain([minVal, maxVal]).range(temp_array);

                            //setScaleGradesLinear(minVal, maxVal, color_list.length);
                            setScaleGradesLogarithmic(minVal, maxVal, 1, 61457, color_list.length);

                            console.log(custom_grades);

                            for(var j=0; j< color_list.length; j++){
                                layers.push(L.layerGroup());
                            } 
                        }
                        counter ++;
                    });
                }

                counter_1 = 1;
                for (var i=0; i<json_list.length; i++)
                {
                    json_path = json_list[i];
                    fetch(json_path)
                    .then(function(response){
                        return response.json();
                    })
                    .then(function(data){
                        //console.log(data);
                        
                        L.geoJSON(data, {
                            style: function (feature) {
                                cus_color = color_list[getIndexOfGrades(feature.properties.flow_acc)];
                                return {color: cus_color};
                            },
                            onEachFeature: function(feature, layer){
                                layers[getIndexOfGrades(feature.properties.flow_acc)].addLayer(layer);
                            }
                        }).bindPopup(function (data) {
                            return "Flow Accumulation: " + data.feature.properties.flow_acc;
                        }).addTo(map);


                        if(counter_1 == json_list.length){ 

                            //console.log(minVal);
                            //console.log(maxVal);
                            legend_text = [];

                            
                            for(var j=0; j<=custom_grades.length; j++)
                            {
                                str_label = "";
                                if(j==0)
                                    str_label += "<= " + custom_grades[j];
                                else if(j==custom_grades.length)
                                    str_label += ">= " + custom_grades[j-1];                                   
                                else
                                    str_label += (custom_grades[j-1]+1) + " - " + custom_grades[j];
                                
                                legend_text.push(str_label);
                            }

                            for(var j=0; j<legend_text.length; j++)
                            {
                                overlayMaps[legend_text[j]] = layers[j];
                                layers[j].addTo(map);
                            }

                            legend.onAdd = function(m){
                                var div = L.DomUtil.create('div', 'info legend');
                                div.innerHTML += "<p>Flow Accumulation</p>"
                                for(var i=0; i<color_list.length; i++)
                                {
                                    div.innerHTML += '<div style="margin-bottom: 2px;"><i style="background:' + color_list[i] + '; opacity:1"></i>' + legend_text[i] + '</div>';
                                }
                                return div;
                            }
                            legend.addTo(map);
                            
                            $('.leaflet-control-layers').remove();
                            L.control.layers(baseLayers, overlayMaps).addTo(map);

                        }
                        counter_1++;
                        

                    });
                    
                }
            }

        }
                
    };

    function setScaleGradesLinear(min, max, no_steps){
        var steps_len = (maxVal-minVal)/no_steps;
        custom_grades = [];
        var prev_val = minVal;
        for(var i=0; i<no_steps-1; i++)
        {
            var val = Math.round(prev_val + steps_len);
            custom_grades.push(val);
            prev_val = val;
        }
    }

    function setScaleGradesLogarithmic(val_min, val_max, log_min, log_max, no_steps){
        custom_grades = [];
        var steps_len = (parseInt(log_max - log_min) / no_steps);

        /*
        for (var i = log_min; i < log_max; i = i + steps_len) {
            var d = val_max - parseInt((Math.log(i) - Math.log(log_min)) / (Math.log(log_max) - Math.log(log_min)) * (val_max - val_min));
            custom_grades.push(d);
        }
        */
        for (var i = 0; i < no_steps; i++) {
            var d = val_max - parseInt((Math.log(log_min+ i*steps_len) - Math.log(log_min)) / (Math.log(log_max) - Math.log(log_min)) * (val_max - val_min));
            custom_grades.push(d);
        }
        custom_grades = custom_grades.reverse();
        custom_grades.pop();
    }

    function getIndexOfGrades(val){
        for(var i=0; i<custom_grades.length; i++)
        {
            if(val <= custom_grades[i])
                return i;
        }
        return i;
    }
</script>



</body>
</html>